#!/bin/bash
#set -x
scriptdir=$(dirname $(realpath $0))
configdir=$scriptdir/config
srcdir=$scriptdir/src

findSymlib()
{
    function fsymlib() {
	if [[ -d Symlib ]]; then
	    echo $(pwd -P)/Symlib
	elif [[ $(pwd -P) != / ]]; then
	    cd ..
	    fsymlib
	fi
    }
    cd $scriptdir
    fsymlib
}

findlinuxdir()
{
    if [[ -d linux ]]; then
	echo $(pwd -P)/linux
    elif [[ $(pwd -P) != $HOME ]]; then
	cd ..
	findlinuxdir
    fi
}

[[ -z $LINUX_BUILD_PATH ]] && [[ -a $configdir/LINUX_BUILD_PATH ]] \
    && LINUX_BUILD_PATH=$(< $configdir/LINUX_BUILD_PATH)

[[ -z $LINUX_BUILD_PATH ]] && LINUX_BUILD_PATH=$(findlinuxdir)

[[ -z $LINUX_BUILD_PATH ]] && {
    echo "ERROR: LINUX_BUILD_PATH not set.  Either environment variable to path of your linux build or put path in $configdir/LINUX_BUILD_PATH" > /dev/stderr
    exit -1
}

symlibdir=$(findSymlib)

[[ -z $symlibdir ]] && {
    echo "ERROR: can't seem to find a Symlib. Need to checkout Symlib and build it." > /dev/stderr
    exit -1
}
   
[[ -d $symlibdir/dynam_build/libSym.so ]] && {
    echo "ERROR: can't find $symlibdir/dynam_build/libSym.so ... maybe you need to build it." > /dev/stderr 
    exit -1
}

LINUX_BUILD_PATH=${LINUX_BUILD_PATH:-$(realpath ../linux)}
curdir=$PWD
tmpdir=$curdir/.ext

[[ ! -d $tmpdir ]] && mkdir $tmpdir

target=${target:-ext.kbin}
name=${target%.kbin}

[[ -z $target ]] && {
    echo "USAGE: kcc [source]"
    exit -1
}

if (( $# > 0 )); then
    src=( $@ )
else
    src=( $(find $PWD -maxdepth 1 -name '*.kc') )
fi

(( ! ${#src[@]} ))  && {
    echo "No .kc source files" > /dev/stderr
    exit -1
}

declare -a cfiles
for s in ${src[@]}; do
    [[ ! -a $s ]] && {
	echo "Can't find $s" > /dev/stderr
	continue
    }
    t=$(basename ${s%.kc}.c)
    [[ ! -a $tmpdir/$t ]] && ln -s $s $tmpdir/$t
    cfiles+=($t)
done


[[ ! -a $tmpdir/init.c ]] && {
    cat > $tmpdir/init.c <<EOF
#include <linux/module.h>

//  Define the module metadata.
#define MODULE_NAME "DYNPRIV_EXTENSION"
MODULE_AUTHOR("BU SESA");
MODULE_LICENSE("GPL v2");
MODULE_DESCRIPTION("BU SESA DYNPRIV PROCESS EXTENSION");
MODULE_VERSION("0.1b");

//  Define the name parameter.
static char *name = "dynpriv extension";
module_param(name, charp, S_IRUGO);
MODULE_PARM_DESC(name, "The name to display in /var/log/kern.log");


static int __init extension_init(void)
{
  pr_info("%s: module loaded at 0x%p\n", MODULE_NAME, extension_init);
  pr_info("%s: args: name=%s\n", MODULE_NAME, name);
  return 0;
}

static void __exit extension_exit(void)
{
    pr_info("%s: goodbye %s\n", MODULE_NAME, name);
    pr_info("%s: module unloaded from 0x%p\n", MODULE_NAME, extension_exit);
}

module_init(extension_init);
module_exit(extension_exit);
EOF
}

[[ ! -a $tmpdir/dpld.c ]] && {
    cp $srcdir/dpld.c $tmpdir
}

cat > $tmpdir/Makefile <<EOF
obj-m += ${name}.o
${name}-y := \$(patsubst %.c,%.o,$cfiles) init.o
ccflags-y := -I $curdir
.PHONY: all clean

all: libextension.a

ext.kbin: ext.ko
	ld -r -b binary -z noexecstack -o \$@ \$<

ext.ko:
	make -C ${LINUX_BUILD_PATH} M=${tmpdir} modules

libextension.a: dpld.o extension.o ext.kbin
	ar rcs \$@ \$^

dpld.o: dpld.c
	gcc -Wall -Wextra -mno-red-zone -fno-omit-frame-pointer -Wfatal-errors -fPIC -I $symlibdir/include -DDDYNLINK -c -o \$@ \$<

extension.o: extension.c
	gcc -c -o \$@ \$<

extension.c extension.h: $cfiles
	$scriptdir/genifunc extension.h \$@ \$^

clean:
	make -C ${LINUX_BUILD_PATH} M=${tmpdir} clean
	-rm -rf \$(wildcard *.o extension.c extension.h libextension.a ext.ko ext.bin )

EOF

make -C $tmpdir

(( $? )) && {
    echo "ERROR: look in $tmpdir" > /dev/stderr
    exit -1
}

rtdir=$(realpath --relative-to=$PWD $tmpdir)

[[ ! -a extension.h ]] && ln -s $rtdir/extension.h .
[[ ! -a libextension.a ]] && ln -s $rtdir/libextension.a .
cp /proc/libkallsyms.so /proc/libkallsyms.a $curdir

#[[ ! -a ext.kbin ]] && ln -s $rtdir/ext.kbin .
exit 0
